{"version":3,"names":["define","_","urlUtil","_interopDefaultLegacy","e","default","___default","urlUtil__default","checkStrategy","strategy","isPlainObject","isFunction","handle","isString","name","TypeError","assetManagerFactory","strategies","data","options","assetManager","cache","isArray","defaults","parseUrl","_strategies","addStrategy","push","prependStrategy","unshift","setStrategies","newStrategies","self","forEach","length","setData","key","value","getData","resolve","url","resolved","inputUrl","parse","result","resolveBy","find","clearCache","prependToUrl","base","slashcat","replace","directory","encodeURIComponent","file","packedUrl","handlePackedUrl","type","isUndefined","source","assets","findKey","isAbsolute","baseUrl","handleBaseUrl","isRelative","itemCssNoCache","handleItemCss","test","build","bust","Date","now","external","handleExternal","toString","base64","handleB64","isBase64","taomedia","handleTaoMedia","protocol","$","eventifier","$__default","eventifier__default","assetManagerFactory__default","itemRunnerFactory","providerName","arguments","flow","init","done","pending","render","providers","Object","keys","Error","provider","defaultStrategy","suspended","closed","container","newData","initDone","filter","pendingTask","trigger","assign","call","contextData","assetManagerOptions","err","message","elt","newOptions","renderDone","state","HTMLElement","setState","get","clear","clearDone","getState","isInitialStateRestore","Array","itemData","Promise","getOptions","setOptions","getResponses","renderFeedbacks","feedbacks","itemSession","suspend","then","close","resume","isSuspended","isClosed","register","registerProvider"],"sources":["../assets/manager.js","../assets/strategies.js","../runner/api/itemRunner.js","module-create.js"],"sourcesContent":["define('taoItems/assets/manager',['lodash', 'util/url'], (function (_, urlUtil) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var ___default = /*#__PURE__*/_interopDefaultLegacy(_);\n    var urlUtil__default = /*#__PURE__*/_interopDefaultLegacy(urlUtil);\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2015-2019 (original work) Open Assessment Technologies SA;\n     *\n     */\n\n    /**\n     * @typedef AssetStrategy Defines a way to resolve an asset path\n     * @property {String} name - the strategy name\n     * @property {assetStrategyHandle} handle - how to resolve the strategy.\n     */\n\n    /**\n     * @callback assetStrategyHandle\n     * @param {String|Object} url - the URL to resolved. If parseUrl, it's an object that contains host, port, search, queryString, etc.\n     * @param {Object} data - the context data\n     * @returns {String?} falsy if not resolved otherwise the resolved URL\n     */\n\n    /**\n     * Check if the given object is a valid AssetStrategy\n     * @param {AssetStrategy} strategy\n     * @throws {TypeError}\n     */\n    var checkStrategy = function checkStrategy(strategy) {\n        if (!___default[\"default\"].isPlainObject(strategy) || !___default[\"default\"].isFunction(strategy.handle) || !___default[\"default\"].isString(strategy.name)) {\n            throw new TypeError('An asset resolution strategy is an object with a handle method and a name');\n        }\n    };\n\n    /**\n     * The assetManagerFactory create a new assetManager with the given resolution strategies and a data context.\n     *\n     * @example\n     *   //define AssetStrategies with a name and a handle method\n     *   var strategies = [{\n     *       name : 'external',\n     *       handle : function(url, data){\n     *           if(/^http/.test(url)){\n     *               return path;\n     *           }\n     *       }\n     *   }, {\n     *       name : 'relative',\n     *       handle : function(url, data){\n     *           if(/^((\\.\\/)|(\\w\\/))/){\n     *               return data.baseUrl + '/' + url ;\n     *           }\n     *       }\n     *   }]);\n     *\n     *   var assetManager = assetManagerFactory(strategies, { baseUrl : 'http://t.oa/public/assets/' });\n     *   assetManager.resolve('http://foo/bar.png'); //will resolved using external\n     *   assetManager.resolve('bar.png'); //will resolved using relative strategy\n     *\n     * @param {AssetStrategy[]} strategies - the strategies\n     * @param {Object} data - the context data\n     * @param {Object} [options] - the manager options\n     * @param {Boolean} [options.parseUrl = true] - If the URL to give to the strategies should be parsed or given as it is.\n     * @param {Boolean} [options.cache] - resolve the same URL only once and store the result in memory.\n     *\n     * @exports taoItems/assets/manager\n     * @namespace assetManagerFactory\n     * @returns {Object} Asset manager\n     */\n    var assetManagerFactory = function assetManagerFactory(strategies, data, options) {\n        var cache = {},\n            assetManager;\n\n        strategies = ___default[\"default\"].isArray(strategies) ? strategies : [strategies];\n        data = data || {};\n        options = ___default[\"default\"].defaults(options || {}, {\n            parseUrl: true\n        });\n\n        /**\n         * A brand new asset manager is created by the factory\n         */\n        assetManager = {\n            /**\n             * The stack of strategies that would be used to resolve the asset path\n             * @type {AssetStrategy[]}\n             */\n            _strategies: [],\n\n            /**\n             * Add an asset resolution strategy at the end of the stack.\n             * The strategies will be evaluated in the order they've been added.\n             * @param {AssetStrategy} strategy - the strategy to add\n             * @throws {TypeError} if the strategy isn't defined correctly\n             */\n            addStrategy: function addStrategy(strategy) {\n                checkStrategy(strategy);\n\n                this._strategies.push(strategy);\n            },\n\n            /**\n             * Add an asset resolution strategy at the beginning of the stack.\n             * The strategies will be evaluated in the order they've been added.\n             * @param {AssetStrategy} strategy - the strategy to add\n             * @throws {TypeError} if the strategy isn't defined correctly\n             */\n            prependStrategy: function prependStrategy(strategy) {\n                checkStrategy(strategy);\n\n                this._strategies.unshift(strategy);\n            },\n\n            /**\n             * Change the strategies\n             * @param {AssetStrategy[]} newStrategies - the strategies\n             * @throws {TypeError} if the strategy isn't defined correctly\n             */\n            setStrategies: function setStrategies(newStrategies) {\n                var self = this;\n\n                this._strategies = [];\n\n                //assign the strategies to the assetManager\n                ___default[\"default\"].forEach(newStrategies, function(strategy) {\n                    //if it's an object we add it directly\n                    if (___default[\"default\"].isPlainObject(strategy)) {\n                        assetManager.addStrategy(strategy);\n\n                        //if it's a function, we create the strategy with a generated name\n                    } else if (___default[\"default\"].isFunction(strategy)) {\n                        self.addStrategy({\n                            name: `strategy_${self._strategies.length + 1}`,\n                            handle: strategy\n                        });\n                    }\n                });\n            },\n\n            /**\n             * Set context data\n             * @param {String|Object} [key] - the key of the data to set or the data values if it's an object\n             * @param {*} [value] - the value to set if a key is given\n             */\n            setData: function setData(key, value) {\n                if (___default[\"default\"].isString(key) && typeof value !== 'undefined') {\n                    data[key] = value;\n                } else if (___default[\"default\"].isPlainObject(key)) {\n                    data = key;\n                }\n            },\n\n            /**\n             * Get context data\n             * @param {String} [key] - if we want the value of a particular key\n             * @returns {Object|*} all the data or the propriety value if key is given\n             */\n            getData: function getData(key) {\n                if (___default[\"default\"].isString(key)) {\n                    return data[key];\n                }\n                return data;\n            },\n\n            /**\n             * Resolve the given URL against the strategies\n             * @param {String} url - the URL to resolve\n             * @returns {String?} the resolved URL or nothing\n             */\n            resolve: function resolve(url) {\n                var resolved;\n                var inputUrl;\n\n                //if caching try to load the value from the cache\n                if (options.cache && typeof cache[url] !== 'undefined') {\n                    return cache[url];\n                }\n\n                //parse the URL ?\n                inputUrl = options.parseUrl ? urlUtil__default[\"default\"].parse(url) : url;\n\n                //call strategies handlers, in their order until once returns something\n                ___default[\"default\"].forEach(this._strategies, function(strategy) {\n                    var result = strategy.handle(inputUrl, data);\n                    if (result) {\n                        resolved = result;\n                        return false;\n                    }\n                });\n\n                resolved = resolved || '';\n\n                if (options.cache) {\n                    cache[url] = resolved;\n                }\n\n                return resolved;\n            },\n\n            /**\n             * Resolve the given URL against the strategy identified by the given name\n             * @param {String} name - the strategy name\n             * @param {String} url - the URL to resolve\n             * @returns {String?} the resolved URL or nothing\n             */\n            resolveBy: function resolveBy(name, url) {\n                var inputUrl;\n                var resolved = '';\n                var strategy = ___default[\"default\"].find(this._strategies, { name: name });\n                if (strategy) {\n                    //parse the URL ?\n                    inputUrl = options.parseUrl ? urlUtil__default[\"default\"].parse(url) : url;\n                    resolved = strategy.handle(inputUrl, data);\n                }\n                return resolved;\n            },\n\n            /**\n             * When the cache is used, it could be useful to clear the cache\n             */\n            clearCache: function clearCache() {\n                if (options.cache) {\n                    cache = {};\n                }\n            }\n        };\n\n        assetManager.setStrategies(strategies);\n\n        return assetManager;\n    };\n\n    return assetManagerFactory;\n\n}));\n\n","define('taoItems/assets/strategies',['util/url', 'lodash'], (function (urlUtil, _) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var urlUtil__default = /*#__PURE__*/_interopDefaultLegacy(urlUtil);\n    var ___default = /*#__PURE__*/_interopDefaultLegacy(_);\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2015-2019 (original work) Open Assessment Technologies SA;\n     *\n     */\n\n    /**\n     * Prepend a base to an URL\n     * @param {Object} url - a parsed URL\n     * @param {String} base - the base to prepend\n     * @param {Boolean} [slashcat = false] - remove dots, double slashes, etc.\n     * @returns {String} the URL\n     */\n    var prependToUrl = function prependToUrl(url, base, slashcat) {\n        //is slashcat we manage slash concact\n        if (slashcat === true) {\n            return `${base.replace(/\\/$/, '')}/${url.directory.replace(/^\\.\\//, '').replace(/^\\//, '')}${encodeURIComponent(url.file.replace(/^\\.\\//, '').replace(/^\\//, ''))}`;\n        }\n\n        return base + url.directory.replace(/^\\.?\\//, '') + encodeURIComponent(url.file.replace(/^\\.?\\//, ''));\n    };\n\n    /**\n     * Unrelated strategies accessible by there name.\n     * Remember to not use the whole object, but each one in an array since the order matters.\n     *\n     * @exports taoItems/assets/strategies\n     */\n    var strategies = {\n        //the packedUrl will replace the asset with the url given in the assets part\n        //the assetManager should add the assets part to data with .setData('assets' itemData.content.assets)\n        packedUrl: {\n            name: 'packedUrl',\n            handle: function handlePackedUrl(url, data) {\n                var type;\n                if (!___default[\"default\"].isUndefined(url.source) && !___default[\"default\"].isUndefined(data.assets)) {\n                    type = ___default[\"default\"].findKey(data.assets, url.source);\n                    if (type && urlUtil__default[\"default\"].isAbsolute(data.assets[type][url.source])) {\n                        return data.assets[type][url.source];\n                    }\n                }\n            }\n        },\n        //the baseUrl concats the baseUrl in data if the url is relative\n        baseUrl: {\n            name: 'baseUrl',\n            handle: function handleBaseUrl(url, data) {\n                if (typeof data.baseUrl === 'string' && urlUtil__default[\"default\"].isRelative(url)) {\n                    return prependToUrl(url, data.baseUrl, data.slashcat);\n                }\n            }\n        },\n\n        //bust the cache for item CSS\n        itemCssNoCache: {\n            name: 'itemCssNoCache',\n            handle: function handleItemCss(url, data) {\n                if (typeof data.baseUrl === 'string' && urlUtil__default[\"default\"].isRelative(url) && /\\.css$/.test(url.file)) {\n                    return urlUtil__default[\"default\"].build(prependToUrl(url, data.baseUrl, data.slashcat), { bust: Date.now() });\n                }\n            }\n        },\n\n        //absolute URL are just left intact\n        external: {\n            name: 'external',\n            handle: function handleExternal(url) {\n                if (urlUtil__default[\"default\"].isAbsolute(url)) {\n                    return url.toString();\n                }\n            }\n        },\n\n        //the base64 encoded resources are also left intact\n        base64: {\n            name: 'base64',\n            handle: function handleB64(url) {\n                if (urlUtil__default[\"default\"].isBase64(url)) {\n                    return url.toString();\n                }\n            }\n        },\n\n        //special tao media protocol\n        taomedia: {\n            name: 'taomedia',\n            handle: function handleTaoMedia(url, data) {\n                //either a baseUrl is given or if empty, taomedia resources are managed as relative resources\n                var baseUrl = data.baseUrl || './';\n                if ((typeof url === 'object' && url.protocol === 'taomedia') || /^taomedia:\\/\\//.test(url.toString())) {\n                    return baseUrl + url.toString();\n                }\n            }\n        }\n    };\n\n    return strategies;\n\n}));\n\n","define('taoItems/runner/api/itemRunner',['jquery', 'core/eventifier', 'taoItems/assets/manager'], (function ($, eventifier, assetManagerFactory) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var $__default = /*#__PURE__*/_interopDefaultLegacy($);\n    var eventifier__default = /*#__PURE__*/_interopDefaultLegacy(eventifier);\n    var assetManagerFactory__default = /*#__PURE__*/_interopDefaultLegacy(assetManagerFactory);\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2014-2021 (original work) Open Assessment Technlogies SA (under the project TAO-PRODUCT);\n     *\n     */\n\n    /**\n     *\n     * Builds a brand new {@link itemRunner}.\n     *\n     * <strong>The factory is an internal mechanism to create encapsulated contexts.\n     *  I suggest you to use directly the name <i>itemRunner</i> when you require this module.</strong>\n     *\n     * @example require(['itemRunner'], function(itemRunner){\n     *            itemRunner({itemId : 12})\n     *                    .on('statechange', function(state){\n     *\n     *                    })\n     *                    .on('ready', function(){\n     *\n     *                    })\n     *                    .on('response', function(){\n     *\n     *                    })\n     *                   .init()\n     *                   .render($('.item-container'));\n     *          });\n     *\n     * @exports itemRunner\n     * @namespace itemRunnerFactory\n     *\n     * @param {String} [providerName] - the name of a provider previously registered see {@link itemRunnerFactory#register}\n     * @param {Object} [data] - the data of the item to run\n     * @param {Object} [options]\n     *\n     * @returns {itemRunner}\n     */\n    const itemRunnerFactory = function itemRunnerFactory(providerName, data = {}, options = {}) {\n        //flow structure to manage sync calls in an async context.\n        const flow = {\n            init: {\n                done: false,\n                pending: []\n            },\n            render: {\n                done: false,\n                pending: []\n            }\n        };\n\n        //optional params based on type\n        if (typeof providerName === 'object') {\n            data = providerName;\n            providerName = void 0;\n        }\n\n        /*\n         * Select the provider\n         */\n        const providers = itemRunnerFactory.providers;\n\n        //check a provider is available\n        if (!providers || Object.keys(providers).length === 0) {\n            throw new Error('No provider registered');\n        }\n\n        let provider;\n\n        if (typeof providerName === 'string' && providerName.length > 0) {\n            provider = providers[providerName];\n        } else if (Object.keys(providers).length === 1) {\n            //if there is only one provider, then we take this one\n            providerName = Object.keys(providers)[0];\n            provider = providers[providerName];\n        }\n\n        //now we should have a provider\n        if (!provider) {\n            throw new Error('No candidate found for the provider');\n        }\n\n        //set up a default assetManager using a \"do nothing\" strategy\n        const assetManager =\n            options.assetManager ||\n            assetManagerFactory__default[\"default\"](function defaultStrategy(url) {\n                return url.toString();\n            });\n\n        let suspended = false;\n        let closed = false;\n\n        /**\n         * The itemRunner\n         * @typedef {Object} itemRunner\n         */\n\n        /**\n         * @type {itemRunner}\n         * @lends itemRunnerFactory\n         */\n        return eventifier__default[\"default\"]({\n            /**\n             * Items container\n             * @type {HTMLElement}\n             */\n            container: null,\n\n            /**\n             * The asset manager used to resolve asset\n             * @see taoItems/asset/manager\n             * @type {AssetManager}\n             */\n            assetManager,\n\n            /**\n             * To give options to the item runner provider\n             * @type {Object}\n             */\n            options,\n\n            /**\n             * Initialize the runner.\n             * @param {Object} [newData] - just in case you want to change item data (it should not occurs in most case)\n             * @returns {itemRunner} to chain calls\n             *\n             * @fires itemRunner#init\n             */\n            init(newData) {\n                /**\n                 * Call back when init is done\n                 */\n                const initDone = () => {\n                    //manage pending tasks the first time\n                    if (flow.init.done === false) {\n                        flow.init.done = true;\n\n                        flow.init.pending\n                            .filter(pendingTask => typeof pendingTask === 'function')\n                            .forEach(pendingTask => pendingTask());\n\n                        flow.init.pending = [];\n                    }\n\n                    /**\n                     * the runner has initialized correclty the item\n                     * @event itemRunner#init\n                     */\n                    this.trigger('init');\n                };\n\n                //merge data\n                if (newData) {\n                    data = Object.assign(data, newData);\n                }\n\n                if (typeof provider.init === 'function') {\n                    /**\n                     * Calls provider's initialization with item data.\n                     * @callback InitItemProvider\n                     * @param {Object} data - the item data\n                     * @param {Function} done - call once the initialization is done\n                     */\n                    provider.init.call(this, data, initDone);\n                } else {\n                    initDone();\n                }\n\n                return this;\n            },\n\n            /**\n             * Configure the assetManager\n             * @see taoItems/assets/manager\n             * @param {AssetStrategy[]} strategies - the resolving strategies\n             * @param {Object} [contextData] - the context data\n             * @param {Object} [assetManagerOptions] - the asset manager options\n             * @returns {itemRunner} to chain calls\n             */\n            assets(strategies, contextData, assetManagerOptions) {\n                try {\n                    this.assetManager = assetManagerFactory__default[\"default\"](strategies, contextData, assetManagerOptions);\n                } catch (err) {\n                    this.trigger(\n                        'error',\n                        new Error(`Something was wrong while configuring the asset manager : ${err.message}`)\n                    );\n                }\n\n                return this;\n            },\n\n            /**\n             * Initialize the current item.\n             *\n             * @param {HTMLElement|jQueryElement} elt - the DOM element that is going to contain the rendered item.\n             * @param {Object} [newOptions] - to update the runner options\n             * @returns {itemRunner} to chain calls\n             *\n             * @fires itemRunner#ready\n             * @fires itemRunner#render\n             * @fires itemRunner#error if the elt isn't valid\n             *\n             * @fires itemRunner#statechange the provider is reponsible to trigger this event\n             * @fires itemRunner#responsechange  the provider is reponsible to trigger this event\n             */\n            render(elt, newOptions = {}) {\n                /**\n                 * Call back when render is done\n                 */\n                const renderDone = () => {\n                    //manage pending tasks the first time\n                    if (flow.render.done === false) {\n                        flow.render.done = true;\n\n                        flow.render.pending\n                            .filter(pendingTask => typeof pendingTask === 'function')\n                            .forEach(pendingTask => pendingTask());\n\n                        flow.render.pending = [];\n                    }\n\n                    /**\n                     * The item is rendered\n                     * @event itemRunner#render\n                     */\n                    this.trigger('render');\n\n                    /**\n                     * The item is ready.\n                     * Alias of {@link itemRunner#render}\n                     * @event itemRunner#ready\n                     */\n                    this.trigger('ready');\n                };\n\n                options = Object.assign(options || {}, newOptions);\n                if (!options.state) {\n                    options.state = {};\n                }\n\n                //check elt\n                if (!(elt instanceof HTMLElement) && !(elt instanceof $__default[\"default\"])) {\n                    return this.trigger(\n                        'error',\n                        new Error('A valid HTMLElement (or a jquery element) at least is required to render the item')\n                    );\n                }\n\n                //set item state to restore item state after rendering if the provider enables it\n                if (options.state) {\n                    this.setState(options.state, true);\n                }\n\n                if (flow.init.done === false) {\n                    flow.init.pending.push(() => this.render(elt, options));\n                } else {\n                    //we keep a reference to the container\n                    if (elt instanceof $__default[\"default\"]) {\n                        this.container = elt.get(0);\n                    } else {\n                        this.container = elt;\n                    }\n\n                    //the state will be applied only when the rendering is made\n\n                    if (typeof provider.render === 'function') {\n                        /**\n                         * Calls the provider's render\n                         * @callback RendertItemProvider\n                         * @param {HTMLElement} elt - the element to render inside\n                         * @param {Function} done - call once the render is done\n                         * @param {Object} [options] - the array of options that the item runner provider may supports\n                         * @param {Object} [options.state] - pass initial item state to method render() in case the item runner provider require initial state to render\n                         */\n                        provider.render.call(this, this.container, renderDone, options);\n                    } else {\n                        renderDone();\n                    }\n                }\n\n                return this;\n            },\n\n            /**\n             * Clear the running item.\n             * @returns {itemRunner}\n             *\n             * @fires itemRunner#clear\n             */\n            clear() {\n                /**\n                 * Call back when clear is done\n                 */\n                const clearDone = () => {\n                    /**\n                     * The item is ready.\n                     * @event itemRunner#clear\n                     */\n                    this.trigger('clear');\n                };\n\n                if (typeof provider.clear === 'function') {\n                    /**\n                     * Calls the provider's clear\n                     * @callback ClearItemProvider\n                     * @param {HTMLElement} elt - item's container\n                     * @param {Function} done - call once the initialization is done\n                     */\n                    provider.clear.call(this, this.container, clearDone);\n                } else {\n                    clearDone();\n                }\n\n                return this;\n            },\n\n            /**\n             * Get the current state of the running item.\n             *\n             * @returns {Object|Null} state\n             */\n            getState() {\n                if (typeof provider.getState === 'function') {\n                    /**\n                     * Calls the provider's getState\n                     * @callback GetStateItemProvider\n                     * @returns {Object} the state\n                     */\n                    return provider.getState.call(this);\n                }\n                return null;\n            },\n\n            /**\n             * Set the current state of the running item.\n             * This should have the effect to restore the item state.\n             *\n             * @param {Object} state - the new state\n             * @param {boolean} [isInitialStateRestore] - state restoring or not\n             * @returns {itemRunner}\n             *\n             * @fires itemRunner#error if the state type doesn't match\n             */\n            setState(state, isInitialStateRestore = false) {\n                if (!state || typeof state !== 'object' || Array.isArray(state)) {\n                    return this.trigger(\n                        'error',\n                        new Error(`The item's state must be a JavaScript Plain Object: ${typeof state} given`)\n                    );\n                }\n\n                //the state will be applied only when the rendering is made\n                if (flow.render.done === false) {\n                    flow.render.pending.push(() => this.setState(state, isInitialStateRestore));\n                } else if (typeof provider.setState === 'function') {\n                    /**\n                     * Calls the provider's setState\n                     * @callback SetStateItemProvider\n                     * @param {Object} state -  the state to set\n                     */\n                    provider.setState.call(this, state, isInitialStateRestore);\n                }\n                return this;\n            },\n\n            /**\n             * Get the item data.\n             *\n             * @returns {Object} the item's data\n             */\n            getData() {\n                return data;\n            },\n\n            /**\n             * Replaces item data in rendered item\n             * @param {object} itemData\n             * @returns {Promise}\n             */\n            setData(itemData) {\n                data = itemData;\n                if (typeof provider.setData === 'function') {\n                    return provider.setData.call(this, itemData);\n                }\n                return Promise.resolve();\n            },\n\n            /**\n             * Get the item runner options.\n             *\n             * @returns {Object} the item rendering options\n             */\n            getOptions() {\n                return this.options;\n            },\n\n            /**\n             * Replaces item runner's options.\n             * @param {Object} newOptions - the options to set\n             * @returns {Promise}\n             */\n            setOptions(newOptions = {}) {\n                this.options = newOptions;\n                if (typeof provider.setOptions === 'function') {\n                    return provider.setOptions.call(this, this.options);\n                }\n                return Promise.resolve();\n            },\n\n            /**\n             * Get the responses of the running item.\n             *\n             * @returns {Object} the item's responses\n             */\n            getResponses() {\n                if (typeof provider.getResponses === 'function') {\n                    /**\n                     * Calls the provider's getResponses\n                     * @callback GetResponsesItemProvider\n                     * @returns {Object} the responses\n                     */\n                    return provider.getResponses.call(this);\n                }\n                return {};\n            },\n\n            /**\n             * Append the modalFeedbacks into the item and create queue of feedbacks that should be displayed to the user\n             *\n             * @param {Object|Array} feedbacks - all feedbacks of the item\n             * @param {Object|Array} itemSession - determine feedbacks which should be displayed\n             * @param {function} done - runs after loading feedbacks into the item\n             *      # have parameter {Object|Array} renderingQueue with prepared queue of the feedbacks for displaying to the user\n             *\n             *\n             * Example:\n             *\n             *    this.renderFeedbacks({f1: 'feedback1', f2: 'feedback2', f3: 'feedback3'}, ['f2'], function(renderingQueue){\n             *      renderingQueue; // {'feedback2'}\n             *    });\n             */\n            renderFeedbacks(feedbacks, itemSession, done) {\n                if (typeof provider.renderFeedbacks === 'function') {\n                    provider.renderFeedbacks.call(this, feedbacks, itemSession, done);\n                }\n            },\n\n            /**\n             * Call the provider's suspend method\n             * @returns {Promise}\n             */\n            suspend() {\n                if (!suspended && flow.render.done && typeof provider.suspend === 'function') {\n                    return provider.suspend.call(this).then(result => {\n                        suspended = true;\n                        return result;\n                    });\n                }\n                return Promise.resolve();\n            },\n\n            /**\n             * Call the provider's hide method\n             * @returns {Promise}\n             */\n            close() {\n                if (!closed && flow.render.done && typeof provider.close === 'function') {\n                    return provider.close.call(this).then(result => {\n                        closed = true;\n                        return result;\n                    });\n                }\n                return Promise.resolve();\n            },\n\n            /**\n             * Call the provider's resume method.\n             * We can resume a previously suspended or closed item.\n             * @returns {Promise}\n             */\n            resume() {\n                if ( (suspended || closed) && flow.render.done && typeof provider.resume === 'function') {\n                    return provider.resume.call(this).then(result => {\n                        suspended = false;\n                        closed = false;\n                        return result;\n                    });\n                }\n                return Promise.resolve();\n            },\n\n            /**\n             * Is the item runner suspended\n             * @returns {boolean} true if suspended\n             */\n            isSuspended() {\n                return suspended;\n            },\n\n            /**\n             * Is the item runner closed\n             * @returns {boolean} true if closed\n             */\n            isClosed(){\n                return closed;\n            },\n        });\n    };\n\n    /**\n     * Register an <i>Item Runtime Provider</i> into the item runner.\n     * The provider provides the behavior required by the item runner.\n     *\n     * @param {String} name - the provider name will be used to select the provider while instantiating the runner\n     *\n     * @param {Object} provider - the Item Runtime Provider as a plain object. The itemRunner forwards encapsulate and delegate calls to the provider.\n     * @param {InitItemProvider} provider.init - the provider initializes the item from it's data, for example loading libraries, add some listeners, etc.\n     * @param {RenderItemProvider} provider.render - the provider renders the item within the given container element.\n     * @param {ClearItemProvider} [provider.clear] - the provider clears the item.\n     * @param {GetStateItemProvider} [provider.getState] - the provider get the item's state.\n     * @param {SetStateItemProvider} [provider.setState] - the provider restore the item to the given state.\n     * @param {GetRespnsesItemProvider} [provider.getResponses] - the provider gives the current responses.\n     *\n     * @throws TypeError when a wrong provider is given or an empty name.\n     */\n    itemRunnerFactory.register = function registerProvider(name, provider) {\n        //type checking\n        if (typeof name !== 'string' || name.length <= 0) {\n            throw new TypeError('It is required to give a name to your provider.');\n        }\n        if (\n            typeof provider !== 'object' ||\n            (typeof provider.init !== 'function' && typeof provider.render !== 'function')\n        ) {\n            throw new TypeError('A provider is an object that contains at least an init function or a render function.');\n        }\n\n        this.providers = this.providers || {};\n        this.providers[name] = provider;\n    };\n\n    return itemRunnerFactory;\n\n}));\n\n","\ndefine(\"taoItems/loader/taoItemsRunner.bundle\", function(){});\n"],"mappings":"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"}